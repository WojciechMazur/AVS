[
  {
    "prId" : 13,
    "comments" : [
      {
        "author" : {
          "login" : "pkukielka",
          "name" : null,
          "avatarUrl" : null,
          "url" : null
        },
        "body" : "I think logic for basic checking arguments belongs in `CommandLineArguments`",
        "createdAt" : "2020-03-13T12:28:38Z",
        "updatedAt" : null,
        "commit" : "aa6e686a8328839854467529b25b40ec71f21c0b",
        "line" : null,
        "diffHunk" : "@@ -0,0 +1,102 @@\n+package github\n+\n+import java.nio.file.{Path, Paths}\n+\n+import commandLineInterface.CommandLineArguments\n+import common.configuration.ConfigurationFactory.getDefault\n+import org.rogach.scallop.ScallopOption\n+import github.web.{Crawler, Credentials, GithubRepository}\n+import standard.model._\n+import standard.searchScope.{RepositoryConfiguration, RepositoryJSONs, SearchScope}\n+import standard.utils.FilesOperations\n+\n+case class StandardModelCrawler(scope: SearchScope, credentials: Credentials, repository: GithubRepository) {\n+  def download(): List[DiscussionFile] = {\n+    val crawler = Crawler(scope, credentials, repository)\n+    val standardModelFiles = crawler.downloadPullRequests().\n+      flatMap(downloadedPR => ConverterToStandardModel.convert(downloadedPR._2))\n+    standard.utils.mergeFiles(standardModelFiles)\n+  }\n+}\n+\n+object StandardModelCrawler {\n+\n+  def run(globalArguments: CommandLineArguments): Unit = {\n+    implicit def toOption[A](scallopOption: ScallopOption[A]): Option[A] = scallopOption.toOption\n+\n+    val localArguments = globalArguments.github\n+\n+    val githubToken = localArguments.githubToken.getOrElse(\"This field is required...\")"
      },
      {
        "author" : {
          "login" : "pkukielka",
          "name" : null,
          "avatarUrl" : null,
          "url" : null
        },
        "body" : "Also if you are already using `(required = true)` that checks are redundant, aren't they?",
        "createdAt" : "2020-03-13T12:29:39Z",
        "updatedAt" : null,
        "commit" : "aa6e686a8328839854467529b25b40ec71f21c0b",
        "line" : null,
        "diffHunk" : "@@ -0,0 +1,102 @@\n+package github\n+\n+import java.nio.file.{Path, Paths}\n+\n+import commandLineInterface.CommandLineArguments\n+import common.configuration.ConfigurationFactory.getDefault\n+import org.rogach.scallop.ScallopOption\n+import github.web.{Crawler, Credentials, GithubRepository}\n+import standard.model._\n+import standard.searchScope.{RepositoryConfiguration, RepositoryJSONs, SearchScope}\n+import standard.utils.FilesOperations\n+\n+case class StandardModelCrawler(scope: SearchScope, credentials: Credentials, repository: GithubRepository) {\n+  def download(): List[DiscussionFile] = {\n+    val crawler = Crawler(scope, credentials, repository)\n+    val standardModelFiles = crawler.downloadPullRequests().\n+      flatMap(downloadedPR => ConverterToStandardModel.convert(downloadedPR._2))\n+    standard.utils.mergeFiles(standardModelFiles)\n+  }\n+}\n+\n+object StandardModelCrawler {\n+\n+  def run(globalArguments: CommandLineArguments): Unit = {\n+    implicit def toOption[A](scallopOption: ScallopOption[A]): Option[A] = scallopOption.toOption\n+\n+    val localArguments = globalArguments.github\n+\n+    val githubToken = localArguments.githubToken.getOrElse(\"This field is required...\")"
      },
      {
        "author" : {
          "login" : "seleythen",
          "name" : null,
          "avatarUrl" : null,
          "url" : null
        },
        "body" : "But I cannot receive normal field, despite flag it as required. And I am sure, that it is present, but to get value there can be used \"getOrElse\" or \"toOption.get\"",
        "createdAt" : "2020-03-13T12:31:33Z",
        "updatedAt" : null,
        "commit" : "aa6e686a8328839854467529b25b40ec71f21c0b",
        "line" : null,
        "diffHunk" : "@@ -0,0 +1,102 @@\n+package github\n+\n+import java.nio.file.{Path, Paths}\n+\n+import commandLineInterface.CommandLineArguments\n+import common.configuration.ConfigurationFactory.getDefault\n+import org.rogach.scallop.ScallopOption\n+import github.web.{Crawler, Credentials, GithubRepository}\n+import standard.model._\n+import standard.searchScope.{RepositoryConfiguration, RepositoryJSONs, SearchScope}\n+import standard.utils.FilesOperations\n+\n+case class StandardModelCrawler(scope: SearchScope, credentials: Credentials, repository: GithubRepository) {\n+  def download(): List[DiscussionFile] = {\n+    val crawler = Crawler(scope, credentials, repository)\n+    val standardModelFiles = crawler.downloadPullRequests().\n+      flatMap(downloadedPR => ConverterToStandardModel.convert(downloadedPR._2))\n+    standard.utils.mergeFiles(standardModelFiles)\n+  }\n+}\n+\n+object StandardModelCrawler {\n+\n+  def run(globalArguments: CommandLineArguments): Unit = {\n+    implicit def toOption[A](scallopOption: ScallopOption[A]): Option[A] = scallopOption.toOption\n+\n+    val localArguments = globalArguments.github\n+\n+    val githubToken = localArguments.githubToken.getOrElse(\"This field is required...\")"
      }
    ]
  },
  {
    "prId" : 13,
    "comments" : [
      {
        "author" : {
          "login" : "pkukielka",
          "name" : null,
          "avatarUrl" : null,
          "url" : null
        },
        "body" : "You only need to pass subcommand there.\r\nOr, maybe better, we should pass every param separately so cmd line parsing classes won't pollute our code and looking at the class interface it will be immediately obvious what it does.\r\nOr we can stick with passing whole class if you will create named one for github, e.g. `GithubSubcommand`",
        "createdAt" : "2020-03-13T12:33:10Z",
        "updatedAt" : null,
        "commit" : "aa6e686a8328839854467529b25b40ec71f21c0b",
        "line" : 25,
        "diffHunk" : "@@ -0,0 +1,102 @@\n+package github\n+\n+import java.nio.file.{Path, Paths}\n+\n+import commandLineInterface.CommandLineArguments\n+import common.configuration.ConfigurationFactory.getDefault\n+import org.rogach.scallop.ScallopOption\n+import github.web.{Crawler, Credentials, GithubRepository}\n+import standard.model._\n+import standard.searchScope.{RepositoryConfiguration, RepositoryJSONs, SearchScope}\n+import standard.utils.FilesOperations\n+\n+case class StandardModelCrawler(scope: SearchScope, credentials: Credentials, repository: GithubRepository) {\n+  def download(): List[DiscussionFile] = {\n+    val crawler = Crawler(scope, credentials, repository)\n+    val standardModelFiles = crawler.downloadPullRequests().\n+      flatMap(downloadedPR => ConverterToStandardModel.convert(downloadedPR._2))\n+    standard.utils.mergeFiles(standardModelFiles)\n+  }\n+}\n+\n+object StandardModelCrawler {\n+\n+  def run(globalArguments: CommandLineArguments): Unit = {\n+    implicit def toOption[A](scallopOption: ScallopOption[A]): Option[A] = scallopOption.toOption"
      }
    ]
  },
  {
    "prId" : 13,
    "comments" : [
      {
        "author" : {
          "login" : "pkukielka",
          "name" : null,
          "avatarUrl" : null,
          "url" : null
        },
        "body" : "Does that two lines do something else than `Paths.get(...)`?",
        "createdAt" : "2020-03-13T12:38:52Z",
        "updatedAt" : null,
        "commit" : "aa6e686a8328839854467529b25b40ec71f21c0b",
        "line" : null,
        "diffHunk" : "@@ -0,0 +1,102 @@\n+package github\n+\n+import java.nio.file.{Path, Paths}\n+\n+import commandLineInterface.CommandLineArguments\n+import common.configuration.ConfigurationFactory.getDefault\n+import org.rogach.scallop.ScallopOption\n+import github.web.{Crawler, Credentials, GithubRepository}\n+import standard.model._\n+import standard.searchScope.{RepositoryConfiguration, RepositoryJSONs, SearchScope}\n+import standard.utils.FilesOperations\n+\n+case class StandardModelCrawler(scope: SearchScope, credentials: Credentials, repository: GithubRepository) {\n+  def download(): List[DiscussionFile] = {\n+    val crawler = Crawler(scope, credentials, repository)\n+    val standardModelFiles = crawler.downloadPullRequests().\n+      flatMap(downloadedPR => ConverterToStandardModel.convert(downloadedPR._2))\n+    standard.utils.mergeFiles(standardModelFiles)\n+  }\n+}\n+\n+object StandardModelCrawler {\n+\n+  def run(globalArguments: CommandLineArguments): Unit = {\n+    implicit def toOption[A](scallopOption: ScallopOption[A]): Option[A] = scallopOption.toOption\n+\n+    val localArguments = globalArguments.github\n+\n+    val githubToken = localArguments.githubToken.getOrElse(\"This field is required...\")\n+    val credentials = Credentials(githubToken)\n+\n+    exitWithMessage(localArguments.inputRepository.isEmpty, \"Input repository not specified\")\n+    val sourceRepositoryOption = GithubRepository.getFromUrl(localArguments.inputRepository.toOption.get)\n+    exitWithMessage(sourceRepositoryOption.isEmpty, \"Cannot parse input repository URL\")\n+    val sourceRepository = sourceRepositoryOption.get\n+//    val outputRepository = getRepositoryFromUrl(localArguments.outputRepository, localArguments.outputRepositoryBranch)\n+\n+    exitWithMessage(localArguments.outputRepository.isEmpty, \"Output repository not present\")\n+    val outputDirectory = generatePathToOutputDirectory(localArguments.outputRepository.toOption.get)\n+    createDirectory(outputDirectory)\n+//    cloneAndCheckoutOutputRepository(outputDirectory, localArguments)\n+\n+    val searchScopeBegin = getSearchScopeBegin(outputDirectory, localArguments.searchScopeBegin)\n+    val searchScopeEnd = getSearchScopeEnd(sourceRepository, credentials, localArguments.searchScopeEnd)\n+    val searchScope = SearchScope(searchScopeBegin, searchScopeEnd)\n+\n+    val crawler = StandardModelCrawler(searchScope, credentials, sourceRepository)\n+    val standardModelFiles = crawler.download()\n+\n+    FilesOperations.saveAllDiscussions(outputDirectory, standardModelFiles)\n+    standard.searchScope.RepositoryConfiguration.saveSearchScopeInConfiguration(outputDirectory, searchScope)\n+//    commit(outputDirectory, timestamp)\n+//    pushToOutputRepository()\n+  }\n+\n+  def exitWithMessage(ifExit: Boolean, message: String): Unit = {\n+    if(ifExit) {\n+      println(message)\n+      System.exit(1)\n+    }\n+  }\n+\n+  def generatePathToOutputDirectory(outputRepositoryURL: String): Path = {\n+    val urlParser = new java.net.URI(outputRepositoryURL)"
      }
    ]
  },
  {
    "prId" : 13,
    "comments" : [
      {
        "author" : {
          "login" : "pkukielka",
          "name" : null,
          "avatarUrl" : null,
          "url" : null
        },
        "body" : "Please reformat and optimize imports in all files",
        "createdAt" : "2020-03-13T12:39:14Z",
        "updatedAt" : null,
        "commit" : "aa6e686a8328839854467529b25b40ec71f21c0b",
        "line" : null,
        "diffHunk" : "@@ -0,0 +1,102 @@\n+package github\n+\n+import java.nio.file.{Path, Paths}\n+\n+import commandLineInterface.CommandLineArguments\n+import common.configuration.ConfigurationFactory.getDefault\n+import org.rogach.scallop.ScallopOption\n+import github.web.{Crawler, Credentials, GithubRepository}\n+import standard.model._\n+import standard.searchScope.{RepositoryConfiguration, RepositoryJSONs, SearchScope}\n+import standard.utils.FilesOperations\n+\n+case class StandardModelCrawler(scope: SearchScope, credentials: Credentials, repository: GithubRepository) {\n+  def download(): List[DiscussionFile] = {\n+    val crawler = Crawler(scope, credentials, repository)\n+    val standardModelFiles = crawler.downloadPullRequests().\n+      flatMap(downloadedPR => ConverterToStandardModel.convert(downloadedPR._2))\n+    standard.utils.mergeFiles(standardModelFiles)\n+  }\n+}\n+\n+object StandardModelCrawler {\n+\n+  def run(globalArguments: CommandLineArguments): Unit = {\n+    implicit def toOption[A](scallopOption: ScallopOption[A]): Option[A] = scallopOption.toOption\n+\n+    val localArguments = globalArguments.github\n+\n+    val githubToken = localArguments.githubToken.getOrElse(\"This field is required...\")\n+    val credentials = Credentials(githubToken)\n+\n+    exitWithMessage(localArguments.inputRepository.isEmpty, \"Input repository not specified\")\n+    val sourceRepositoryOption = GithubRepository.getFromUrl(localArguments.inputRepository.toOption.get)\n+    exitWithMessage(sourceRepositoryOption.isEmpty, \"Cannot parse input repository URL\")\n+    val sourceRepository = sourceRepositoryOption.get\n+//    val outputRepository = getRepositoryFromUrl(localArguments.outputRepository, localArguments.outputRepositoryBranch)\n+\n+    exitWithMessage(localArguments.outputRepository.isEmpty, \"Output repository not present\")\n+    val outputDirectory = generatePathToOutputDirectory(localArguments.outputRepository.toOption.get)\n+    createDirectory(outputDirectory)\n+//    cloneAndCheckoutOutputRepository(outputDirectory, localArguments)\n+\n+    val searchScopeBegin = getSearchScopeBegin(outputDirectory, localArguments.searchScopeBegin)\n+    val searchScopeEnd = getSearchScopeEnd(sourceRepository, credentials, localArguments.searchScopeEnd)\n+    val searchScope = SearchScope(searchScopeBegin, searchScopeEnd)\n+\n+    val crawler = StandardModelCrawler(searchScope, credentials, sourceRepository)\n+    val standardModelFiles = crawler.download()\n+\n+    FilesOperations.saveAllDiscussions(outputDirectory, standardModelFiles)\n+    standard.searchScope.RepositoryConfiguration.saveSearchScopeInConfiguration(outputDirectory, searchScope)\n+//    commit(outputDirectory, timestamp)\n+//    pushToOutputRepository()\n+  }\n+\n+  def exitWithMessage(ifExit: Boolean, message: String): Unit = {\n+    if(ifExit) {"
      }
    ]
  },
  {
    "prId" : 13,
    "comments" : [
      {
        "author" : {
          "login" : "pkukielka",
          "name" : null,
          "avatarUrl" : null,
          "url" : null
        },
        "body" : "If you will start fold with 1 you can remove that whole if/else.\r\nLower number is invalid anyway, so if user provides it we don't care (and in cast we could/should fail when parsing args)",
        "createdAt" : "2020-03-13T12:42:31Z",
        "updatedAt" : null,
        "commit" : "aa6e686a8328839854467529b25b40ec71f21c0b",
        "line" : null,
        "diffHunk" : "@@ -0,0 +1,102 @@\n+package github\n+\n+import java.nio.file.{Path, Paths}\n+\n+import commandLineInterface.CommandLineArguments\n+import common.configuration.ConfigurationFactory.getDefault\n+import org.rogach.scallop.ScallopOption\n+import github.web.{Crawler, Credentials, GithubRepository}\n+import standard.model._\n+import standard.searchScope.{RepositoryConfiguration, RepositoryJSONs, SearchScope}\n+import standard.utils.FilesOperations\n+\n+case class StandardModelCrawler(scope: SearchScope, credentials: Credentials, repository: GithubRepository) {\n+  def download(): List[DiscussionFile] = {\n+    val crawler = Crawler(scope, credentials, repository)\n+    val standardModelFiles = crawler.downloadPullRequests().\n+      flatMap(downloadedPR => ConverterToStandardModel.convert(downloadedPR._2))\n+    standard.utils.mergeFiles(standardModelFiles)\n+  }\n+}\n+\n+object StandardModelCrawler {\n+\n+  def run(globalArguments: CommandLineArguments): Unit = {\n+    implicit def toOption[A](scallopOption: ScallopOption[A]): Option[A] = scallopOption.toOption\n+\n+    val localArguments = globalArguments.github\n+\n+    val githubToken = localArguments.githubToken.getOrElse(\"This field is required...\")\n+    val credentials = Credentials(githubToken)\n+\n+    exitWithMessage(localArguments.inputRepository.isEmpty, \"Input repository not specified\")\n+    val sourceRepositoryOption = GithubRepository.getFromUrl(localArguments.inputRepository.toOption.get)\n+    exitWithMessage(sourceRepositoryOption.isEmpty, \"Cannot parse input repository URL\")\n+    val sourceRepository = sourceRepositoryOption.get\n+//    val outputRepository = getRepositoryFromUrl(localArguments.outputRepository, localArguments.outputRepositoryBranch)\n+\n+    exitWithMessage(localArguments.outputRepository.isEmpty, \"Output repository not present\")\n+    val outputDirectory = generatePathToOutputDirectory(localArguments.outputRepository.toOption.get)\n+    createDirectory(outputDirectory)\n+//    cloneAndCheckoutOutputRepository(outputDirectory, localArguments)\n+\n+    val searchScopeBegin = getSearchScopeBegin(outputDirectory, localArguments.searchScopeBegin)\n+    val searchScopeEnd = getSearchScopeEnd(sourceRepository, credentials, localArguments.searchScopeEnd)\n+    val searchScope = SearchScope(searchScopeBegin, searchScopeEnd)\n+\n+    val crawler = StandardModelCrawler(searchScope, credentials, sourceRepository)\n+    val standardModelFiles = crawler.download()\n+\n+    FilesOperations.saveAllDiscussions(outputDirectory, standardModelFiles)\n+    standard.searchScope.RepositoryConfiguration.saveSearchScopeInConfiguration(outputDirectory, searchScope)\n+//    commit(outputDirectory, timestamp)\n+//    pushToOutputRepository()\n+  }\n+\n+  def exitWithMessage(ifExit: Boolean, message: String): Unit = {\n+    if(ifExit) {\n+      println(message)\n+      System.exit(1)\n+    }\n+  }\n+\n+  def generatePathToOutputDirectory(outputRepositoryURL: String): Path = {\n+    val urlParser = new java.net.URI(outputRepositoryURL)\n+    val urlPath = urlParser.getPath\n+    val outputDirectoryName = urlPath.replace(\".git\", \"\").replace(\"/\", \"_\")\n+    val repositoriesDirectory = getDefault().getString(\"repository.directoryForRepositories\")\n+        .replace(\"~\", System.getProperty(\"user.home\"))\n+    Path.of(repositoriesDirectory, outputDirectoryName)\n+  }\n+\n+  def getSearchScopeBegin(pathToRepository: Path, searchScopeBegin: Option[Int]): Int = {\n+    searchScopeBegin.getOrElse(findSearchScopeBegin(pathToRepository))\n+  }\n+\n+  def findSearchScopeBegin(path: Path) = {\n+    val searchScopesFromConfiguration = RepositoryConfiguration.getSearchScopes(path)\n+    if(searchScopesFromConfiguration.nonEmpty) {\n+      searchScopesFromConfiguration.foldRight(Int.MinValue)((searchScope, lastMax) => Math.max(lastMax, searchScope.end))\n+    } else {\n+      val searchScope = RepositoryJSONs.getSearchScopeFromDirectory(path)\n+      val lastPRNumber = searchScope.end\n+      if(lastPRNumber < 0) {"
      }
    ]
  },
  {
    "prId" : 13,
    "comments" : [
      {
        "author" : {
          "login" : "pkukielka",
          "name" : null,
          "avatarUrl" : null,
          "url" : null
        },
        "body" : "What about things like `:`?\r\nI think it would be generally safer to use `URI` and then `getPath`\r\nhttps://stackoverflow.com/questions/6890565/how-do-i-decompose-a-url-into-its-component-parts-in-java \r\nand then or replace `/` with `_`, or just use given path as directory structure (could be safer, as replacement would result in `x_y/z` and `x/y_z` being the same fles)",
        "createdAt" : "2020-03-13T13:02:30Z",
        "updatedAt" : null,
        "commit" : "aa6e686a8328839854467529b25b40ec71f21c0b",
        "line" : null,
        "diffHunk" : "@@ -0,0 +1,102 @@\n+package github\n+\n+import java.nio.file.{Path, Paths}\n+\n+import commandLineInterface.CommandLineArguments\n+import common.configuration.ConfigurationFactory.getDefault\n+import org.rogach.scallop.ScallopOption\n+import github.web.{Crawler, Credentials, GithubRepository}\n+import standard.model._\n+import standard.searchScope.{RepositoryConfiguration, RepositoryJSONs, SearchScope}\n+import standard.utils.FilesOperations\n+\n+case class StandardModelCrawler(scope: SearchScope, credentials: Credentials, repository: GithubRepository) {\n+  def download(): List[DiscussionFile] = {\n+    val crawler = Crawler(scope, credentials, repository)\n+    val standardModelFiles = crawler.downloadPullRequests().\n+      flatMap(downloadedPR => ConverterToStandardModel.convert(downloadedPR._2))\n+    standard.utils.mergeFiles(standardModelFiles)\n+  }\n+}\n+\n+object StandardModelCrawler {\n+\n+  def run(globalArguments: CommandLineArguments): Unit = {\n+    implicit def toOption[A](scallopOption: ScallopOption[A]): Option[A] = scallopOption.toOption\n+\n+    val localArguments = globalArguments.github\n+\n+    val githubToken = localArguments.githubToken.getOrElse(\"This field is required...\")\n+    val credentials = Credentials(githubToken)\n+\n+    exitWithMessage(localArguments.inputRepository.isEmpty, \"Input repository not specified\")\n+    val sourceRepositoryOption = GithubRepository.getFromUrl(localArguments.inputRepository.toOption.get)\n+    exitWithMessage(sourceRepositoryOption.isEmpty, \"Cannot parse input repository URL\")\n+    val sourceRepository = sourceRepositoryOption.get\n+//    val outputRepository = getRepositoryFromUrl(localArguments.outputRepository, localArguments.outputRepositoryBranch)\n+\n+    exitWithMessage(localArguments.outputRepository.isEmpty, \"Output repository not present\")\n+    val outputDirectory = generatePathToOutputDirectory(localArguments.outputRepository.toOption.get)\n+    createDirectory(outputDirectory)\n+//    cloneAndCheckoutOutputRepository(outputDirectory, localArguments)\n+\n+    val searchScopeBegin = getSearchScopeBegin(outputDirectory, localArguments.searchScopeBegin)\n+    val searchScopeEnd = getSearchScopeEnd(sourceRepository, credentials, localArguments.searchScopeEnd)\n+    val searchScope = SearchScope(searchScopeBegin, searchScopeEnd)\n+\n+    val crawler = StandardModelCrawler(searchScope, credentials, sourceRepository)\n+    val standardModelFiles = crawler.download()\n+\n+    FilesOperations.saveAllDiscussions(outputDirectory, standardModelFiles)\n+    standard.searchScope.RepositoryConfiguration.saveSearchScopeInConfiguration(outputDirectory, searchScope)\n+//    commit(outputDirectory, timestamp)\n+//    pushToOutputRepository()\n+  }\n+\n+  def exitWithMessage(ifExit: Boolean, message: String): Unit = {\n+    if(ifExit) {\n+      println(message)\n+      System.exit(1)\n+    }\n+  }\n+\n+  def generatePathToOutputDirectory(outputRepositoryURL: String): Path = {\n+    val urlParser = new java.net.URI(outputRepositoryURL)\n+    val urlPath = urlParser.getPath\n+    val outputDirectoryName = urlPath.replace(\".git\", \"\").replace(\"/\", \"_\")"
      }
    ]
  },
  {
    "prId" : 13,
    "comments" : [
      {
        "author" : {
          "login" : "pkukielka",
          "name" : null,
          "avatarUrl" : null,
          "url" : null
        },
        "body" : "Commented out code?",
        "createdAt" : "2020-03-17T09:34:00Z",
        "updatedAt" : null,
        "commit" : "aa6e686a8328839854467529b25b40ec71f21c0b",
        "line" : null,
        "diffHunk" : "@@ -0,0 +1,87 @@\n+package github\n+\n+import java.nio.file.Path\n+\n+import commandLineInterface.CommandLineArguments.GithubSubcommand\n+import common.configuration.ConfigurationFactory\n+import github.web.{Crawler, Credentials, GithubRepository}\n+import org.rogach.scallop.ScallopOption\n+import standard.model._\n+import standard.searchScope.{RepositoryConfiguration, RepositoryJSONs, SearchScope}\n+import standard.utils.FilesOperations\n+\n+case class StandardModelCrawler(scope: SearchScope, credentials: Credentials, repository: GithubRepository) {\n+  def download(): List[DiscussionFile] = {\n+    val crawler = Crawler(scope, credentials, repository)\n+    val standardModelFiles = crawler.downloadPullRequests().\n+      flatMap(downloadedPR => ConverterToStandardModel.convert(downloadedPR._2))\n+    standard.utils.mergeDiscussionFiles(standardModelFiles)\n+  }\n+}\n+\n+object StandardModelCrawler {\n+\n+  def run(localArguments: GithubSubcommand): Unit = {\n+    implicit def toOption[A](scallopOption: ScallopOption[A]): Option[A] = scallopOption.toOption\n+\n+    val githubToken = localArguments.githubToken.toOption.get\n+    val credentials = Credentials(githubToken)\n+\n+    val sourceRepositoryOption = GithubRepository.getFromUrl(localArguments.inputRepository.toOption.get)\n+    val sourceRepository = sourceRepositoryOption.get\n+//    val outputRepository = getRepositoryFromUrl(localArguments.outputRepository, localArguments.outputRepositoryBranch)"
      },
      {
        "author" : {
          "login" : "seleythen",
          "name" : null,
          "avatarUrl" : null,
          "url" : null
        },
        "body" : "Comments for next functionality. In this PR it is not needed. I will remove it",
        "createdAt" : "2020-03-17T12:23:37Z",
        "updatedAt" : null,
        "commit" : "aa6e686a8328839854467529b25b40ec71f21c0b",
        "line" : null,
        "diffHunk" : "@@ -0,0 +1,87 @@\n+package github\n+\n+import java.nio.file.Path\n+\n+import commandLineInterface.CommandLineArguments.GithubSubcommand\n+import common.configuration.ConfigurationFactory\n+import github.web.{Crawler, Credentials, GithubRepository}\n+import org.rogach.scallop.ScallopOption\n+import standard.model._\n+import standard.searchScope.{RepositoryConfiguration, RepositoryJSONs, SearchScope}\n+import standard.utils.FilesOperations\n+\n+case class StandardModelCrawler(scope: SearchScope, credentials: Credentials, repository: GithubRepository) {\n+  def download(): List[DiscussionFile] = {\n+    val crawler = Crawler(scope, credentials, repository)\n+    val standardModelFiles = crawler.downloadPullRequests().\n+      flatMap(downloadedPR => ConverterToStandardModel.convert(downloadedPR._2))\n+    standard.utils.mergeDiscussionFiles(standardModelFiles)\n+  }\n+}\n+\n+object StandardModelCrawler {\n+\n+  def run(localArguments: GithubSubcommand): Unit = {\n+    implicit def toOption[A](scallopOption: ScallopOption[A]): Option[A] = scallopOption.toOption\n+\n+    val githubToken = localArguments.githubToken.toOption.get\n+    val credentials = Credentials(githubToken)\n+\n+    val sourceRepositoryOption = GithubRepository.getFromUrl(localArguments.inputRepository.toOption.get)\n+    val sourceRepository = sourceRepositoryOption.get\n+//    val outputRepository = getRepositoryFromUrl(localArguments.outputRepository, localArguments.outputRepositoryBranch)"
      }
    ]
  }
]