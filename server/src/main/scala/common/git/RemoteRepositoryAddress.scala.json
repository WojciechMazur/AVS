[
  {
    "prId" : 14,
    "comments" : [
      {
        "author" : {
          "login" : "pkukielka",
          "name" : null,
          "avatarUrl" : null,
          "url" : null
        },
        "body" : "Could we use `URI` instead of `String` for storing uri? :)",
        "createdAt" : "2020-03-19T09:51:06Z",
        "updatedAt" : null,
        "commit" : "ddfd942df8471aa889cc44fe8aacc583404a59b6",
        "line" : null,
        "diffHunk" : "@@ -0,0 +1,86 @@\n+package common.git\n+\n+import java.util\n+\n+import common.utils.OptionExtension._\n+import org.eclipse.jgit.api.Git\n+import org.eclipse.jgit.lib.Ref\n+import org.eclipse.jgit.transport.CredentialsProvider\n+\n+import scala.annotation.tailrec\n+\n+class RemoteRepositoryAddress private (val uri: String, val branch: Option[String]) {"
      },
      {
        "author" : {
          "login" : "seleythen",
          "name" : null,
          "avatarUrl" : null,
          "url" : null
        },
        "body" : "It would fail wit address git@... At least java.net.URI throws illegal character exception",
        "createdAt" : "2020-03-19T10:18:57Z",
        "updatedAt" : null,
        "commit" : "ddfd942df8471aa889cc44fe8aacc583404a59b6",
        "line" : null,
        "diffHunk" : "@@ -0,0 +1,86 @@\n+package common.git\n+\n+import java.util\n+\n+import common.utils.OptionExtension._\n+import org.eclipse.jgit.api.Git\n+import org.eclipse.jgit.lib.Ref\n+import org.eclipse.jgit.transport.CredentialsProvider\n+\n+import scala.annotation.tailrec\n+\n+class RemoteRepositoryAddress private (val uri: String, val branch: Option[String]) {"
      },
      {
        "author" : {
          "login" : "pkukielka",
          "name" : null,
          "avatarUrl" : null,
          "url" : null
        },
        "body" : "Okay",
        "createdAt" : "2020-03-19T17:58:57Z",
        "updatedAt" : null,
        "commit" : "ddfd942df8471aa889cc44fe8aacc583404a59b6",
        "line" : null,
        "diffHunk" : "@@ -0,0 +1,86 @@\n+package common.git\n+\n+import java.util\n+\n+import common.utils.OptionExtension._\n+import org.eclipse.jgit.api.Git\n+import org.eclipse.jgit.lib.Ref\n+import org.eclipse.jgit.transport.CredentialsProvider\n+\n+import scala.annotation.tailrec\n+\n+class RemoteRepositoryAddress private (val uri: String, val branch: Option[String]) {"
      }
    ]
  },
  {
    "prId" : 14,
    "comments" : [
      {
        "author" : {
          "login" : "pkukielka",
          "name" : null,
          "avatarUrl" : null,
          "url" : null
        },
        "body" : "You could also use `endsWith` to avoid regexp",
        "createdAt" : "2020-03-19T10:03:00Z",
        "updatedAt" : null,
        "commit" : "ddfd942df8471aa889cc44fe8aacc583404a59b6",
        "line" : null,
        "diffHunk" : "@@ -0,0 +1,86 @@\n+package common.git\n+\n+import java.util\n+\n+import common.utils.OptionExtension._\n+import org.eclipse.jgit.api.Git\n+import org.eclipse.jgit.lib.Ref\n+import org.eclipse.jgit.transport.CredentialsProvider\n+\n+import scala.annotation.tailrec\n+\n+class RemoteRepositoryAddress private (val uri: String, val branch: Option[String]) {\n+  def getRepositoryName: Option[String] = {\n+    val uriFragments = uri.split(\"/\")\n+    uriFragments.findLast(fragment => fragment.matches(\"*.git\"))"
      },
      {
        "author" : {
          "login" : "seleythen",
          "name" : null,
          "avatarUrl" : null,
          "url" : null
        },
        "body" : "Thx, I will change it!",
        "createdAt" : "2020-03-19T10:23:59Z",
        "updatedAt" : null,
        "commit" : "ddfd942df8471aa889cc44fe8aacc583404a59b6",
        "line" : null,
        "diffHunk" : "@@ -0,0 +1,86 @@\n+package common.git\n+\n+import java.util\n+\n+import common.utils.OptionExtension._\n+import org.eclipse.jgit.api.Git\n+import org.eclipse.jgit.lib.Ref\n+import org.eclipse.jgit.transport.CredentialsProvider\n+\n+import scala.annotation.tailrec\n+\n+class RemoteRepositoryAddress private (val uri: String, val branch: Option[String]) {\n+  def getRepositoryName: Option[String] = {\n+    val uriFragments = uri.split(\"/\")\n+    uriFragments.findLast(fragment => fragment.matches(\"*.git\"))"
      }
    ]
  },
  {
    "prId" : 14,
    "comments" : [
      {
        "author" : {
          "login" : "pkukielka",
          "name" : null,
          "avatarUrl" : null,
          "url" : null
        },
        "body" : "Can we put that into configuration?",
        "createdAt" : "2020-03-19T10:03:40Z",
        "updatedAt" : null,
        "commit" : "ddfd942df8471aa889cc44fe8aacc583404a59b6",
        "line" : null,
        "diffHunk" : "@@ -0,0 +1,86 @@\n+package common.git\n+\n+import java.util\n+\n+import common.utils.OptionExtension._\n+import org.eclipse.jgit.api.Git\n+import org.eclipse.jgit.lib.Ref\n+import org.eclipse.jgit.transport.CredentialsProvider\n+\n+import scala.annotation.tailrec\n+\n+class RemoteRepositoryAddress private (val uri: String, val branch: Option[String]) {\n+  def getRepositoryName: Option[String] = {\n+    val uriFragments = uri.split(\"/\")\n+    uriFragments.findLast(fragment => fragment.matches(\"*.git\"))\n+  }\n+\n+  override def hashCode(): Int = uri.length\n+\n+  override def equals(obj: Any): Boolean = {\n+    obj match {\n+      case obj: RemoteRepositoryAddress => obj.branch == branch && obj.uri == uri\n+      case _ => false\n+    }\n+  }\n+}\n+\n+object RemoteRepositoryAddress {\n+  def tryToCreate(uri: String,\n+                credentials: GitCredentials,\n+                branch: Option[String] = None): Either[GitURIException, RemoteRepositoryAddress] = {\n+    correctGitRepository(uri, branch, Some(credentials.getCredentialsProvider)) match {\n+      case Right(_) => Right(new RemoteRepositoryAddress(uri, branch))\n+      case Left(exception) => Left(exception)\n+    }\n+  }\n+\n+  @tailrec def correctGitRepository(uri: String,\n+                                    branch: Option[String],\n+                                    credentials: Option[CredentialsProvider] = None,\n+                                    retryNumber: Int = 0): Either[GitURIException, Boolean] = {\n+    if (retryNumber < 10) {"
      },
      {
        "author" : {
          "login" : "seleythen",
          "name" : null,
          "avatarUrl" : null,
          "url" : null
        },
        "body" : "Done",
        "createdAt" : "2020-03-19T10:30:15Z",
        "updatedAt" : null,
        "commit" : "ddfd942df8471aa889cc44fe8aacc583404a59b6",
        "line" : null,
        "diffHunk" : "@@ -0,0 +1,86 @@\n+package common.git\n+\n+import java.util\n+\n+import common.utils.OptionExtension._\n+import org.eclipse.jgit.api.Git\n+import org.eclipse.jgit.lib.Ref\n+import org.eclipse.jgit.transport.CredentialsProvider\n+\n+import scala.annotation.tailrec\n+\n+class RemoteRepositoryAddress private (val uri: String, val branch: Option[String]) {\n+  def getRepositoryName: Option[String] = {\n+    val uriFragments = uri.split(\"/\")\n+    uriFragments.findLast(fragment => fragment.matches(\"*.git\"))\n+  }\n+\n+  override def hashCode(): Int = uri.length\n+\n+  override def equals(obj: Any): Boolean = {\n+    obj match {\n+      case obj: RemoteRepositoryAddress => obj.branch == branch && obj.uri == uri\n+      case _ => false\n+    }\n+  }\n+}\n+\n+object RemoteRepositoryAddress {\n+  def tryToCreate(uri: String,\n+                credentials: GitCredentials,\n+                branch: Option[String] = None): Either[GitURIException, RemoteRepositoryAddress] = {\n+    correctGitRepository(uri, branch, Some(credentials.getCredentialsProvider)) match {\n+      case Right(_) => Right(new RemoteRepositoryAddress(uri, branch))\n+      case Left(exception) => Left(exception)\n+    }\n+  }\n+\n+  @tailrec def correctGitRepository(uri: String,\n+                                    branch: Option[String],\n+                                    credentials: Option[CredentialsProvider] = None,\n+                                    retryNumber: Int = 0): Either[GitURIException, Boolean] = {\n+    if (retryNumber < 10) {"
      }
    ]
  },
  {
    "prId" : 14,
    "comments" : [
      {
        "author" : {
          "login" : "pkukielka",
          "name" : null,
          "avatarUrl" : null,
          "url" : null
        },
        "body" : "You should be able to convert to `Iterable` instead of `Array` which will keep the type, and won't need that `map` later.",
        "createdAt" : "2020-03-19T10:51:52Z",
        "updatedAt" : null,
        "commit" : "ddfd942df8471aa889cc44fe8aacc583404a59b6",
        "line" : null,
        "diffHunk" : "@@ -0,0 +1,86 @@\n+package common.git\n+\n+import java.util\n+\n+import common.utils.OptionExtension._\n+import org.eclipse.jgit.api.Git\n+import org.eclipse.jgit.lib.Ref\n+import org.eclipse.jgit.transport.CredentialsProvider\n+\n+import scala.annotation.tailrec\n+\n+class RemoteRepositoryAddress private (val uri: String, val branch: Option[String]) {\n+  def getRepositoryName: Option[String] = {\n+    val uriFragments = uri.split(\"/\")\n+    uriFragments.findLast(fragment => fragment.matches(\"*.git\"))\n+  }\n+\n+  override def hashCode(): Int = uri.length\n+\n+  override def equals(obj: Any): Boolean = {\n+    obj match {\n+      case obj: RemoteRepositoryAddress => obj.branch == branch && obj.uri == uri\n+      case _ => false\n+    }\n+  }\n+}\n+\n+object RemoteRepositoryAddress {\n+  def tryToCreate(uri: String,\n+                credentials: GitCredentials,\n+                branch: Option[String] = None): Either[GitURIException, RemoteRepositoryAddress] = {\n+    correctGitRepository(uri, branch, Some(credentials.getCredentialsProvider)) match {\n+      case Right(_) => Right(new RemoteRepositoryAddress(uri, branch))\n+      case Left(exception) => Left(exception)\n+    }\n+  }\n+\n+  @tailrec def correctGitRepository(uri: String,\n+                                    branch: Option[String],\n+                                    credentials: Option[CredentialsProvider] = None,\n+                                    retryNumber: Int = 0): Either[GitURIException, Boolean] = {\n+    if (retryNumber < 10) {\n+      try {\n+        getLsRepositoryIfExist(uri, credentials) match {\n+          case Right(refs) if branch.isDefined => checkIfBranchExist(refs, branch.get)\n+          case Right(_) => Right(true)\n+          case Left(exception) => Left(exception)\n+        }\n+      } catch {\n+        case e: Throwable => correctGitRepository(uri, branch, credentials, retryNumber + 1)\n+      }\n+    } else {\n+      Left(ConnectionBrokenException)\n+    }\n+  }\n+\n+  def getLsRepositoryIfExist(uri: String,\n+                             credentials: Option[CredentialsProvider]): Either[GitURIException, util.Collection[Ref]] = {\n+    try {\n+      val refs = Git.lsRemoteRepository()\n+        .applyIfExist(credentials)(_.setCredentialsProvider)\n+        .setRemote(uri)\n+        .call()\n+      Right(refs)\n+    } catch {\n+      case e: org.eclipse.jgit.errors.NoRemoteRepositoryException => Left(NoRemoteRepositoryException)\n+      case e: org.eclipse.jgit.api.errors.TransportException => Left(CredentialsIncorrectException)\n+    }\n+  }\n+\n+  def checkIfBranchExist(refs: util.Collection[Ref], branch: String): Either[GitURIException, Boolean] = {\n+    if(refs.toArray().map{case ref: Ref => ref}"
      },
      {
        "author" : {
          "login" : "seleythen",
          "name" : null,
          "avatarUrl" : null,
          "url" : null
        },
        "body" : "Not explicit, but using java to scala converters I have managed to do it.   ",
        "createdAt" : "2020-03-19T11:10:17Z",
        "updatedAt" : null,
        "commit" : "ddfd942df8471aa889cc44fe8aacc583404a59b6",
        "line" : null,
        "diffHunk" : "@@ -0,0 +1,86 @@\n+package common.git\n+\n+import java.util\n+\n+import common.utils.OptionExtension._\n+import org.eclipse.jgit.api.Git\n+import org.eclipse.jgit.lib.Ref\n+import org.eclipse.jgit.transport.CredentialsProvider\n+\n+import scala.annotation.tailrec\n+\n+class RemoteRepositoryAddress private (val uri: String, val branch: Option[String]) {\n+  def getRepositoryName: Option[String] = {\n+    val uriFragments = uri.split(\"/\")\n+    uriFragments.findLast(fragment => fragment.matches(\"*.git\"))\n+  }\n+\n+  override def hashCode(): Int = uri.length\n+\n+  override def equals(obj: Any): Boolean = {\n+    obj match {\n+      case obj: RemoteRepositoryAddress => obj.branch == branch && obj.uri == uri\n+      case _ => false\n+    }\n+  }\n+}\n+\n+object RemoteRepositoryAddress {\n+  def tryToCreate(uri: String,\n+                credentials: GitCredentials,\n+                branch: Option[String] = None): Either[GitURIException, RemoteRepositoryAddress] = {\n+    correctGitRepository(uri, branch, Some(credentials.getCredentialsProvider)) match {\n+      case Right(_) => Right(new RemoteRepositoryAddress(uri, branch))\n+      case Left(exception) => Left(exception)\n+    }\n+  }\n+\n+  @tailrec def correctGitRepository(uri: String,\n+                                    branch: Option[String],\n+                                    credentials: Option[CredentialsProvider] = None,\n+                                    retryNumber: Int = 0): Either[GitURIException, Boolean] = {\n+    if (retryNumber < 10) {\n+      try {\n+        getLsRepositoryIfExist(uri, credentials) match {\n+          case Right(refs) if branch.isDefined => checkIfBranchExist(refs, branch.get)\n+          case Right(_) => Right(true)\n+          case Left(exception) => Left(exception)\n+        }\n+      } catch {\n+        case e: Throwable => correctGitRepository(uri, branch, credentials, retryNumber + 1)\n+      }\n+    } else {\n+      Left(ConnectionBrokenException)\n+    }\n+  }\n+\n+  def getLsRepositoryIfExist(uri: String,\n+                             credentials: Option[CredentialsProvider]): Either[GitURIException, util.Collection[Ref]] = {\n+    try {\n+      val refs = Git.lsRemoteRepository()\n+        .applyIfExist(credentials)(_.setCredentialsProvider)\n+        .setRemote(uri)\n+        .call()\n+      Right(refs)\n+    } catch {\n+      case e: org.eclipse.jgit.errors.NoRemoteRepositoryException => Left(NoRemoteRepositoryException)\n+      case e: org.eclipse.jgit.api.errors.TransportException => Left(CredentialsIncorrectException)\n+    }\n+  }\n+\n+  def checkIfBranchExist(refs: util.Collection[Ref], branch: String): Either[GitURIException, Boolean] = {\n+    if(refs.toArray().map{case ref: Ref => ref}"
      }
    ]
  }
]